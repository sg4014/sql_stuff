# ДЗ 10, Оптимизация запроса

## Анализ запроса
В теле ролевой функции имеем запрос:
```sql
select
    tripRequest."InstanceID" as "CardID", -- Ид карточки
    observers."EmployeeID" as "Value", -- Ид сотрудника
    13 as "Type" -- Константа, 13 - тип поля ссылка внутри ДВ
from "dvtable_{51c333e6-a252-4139-a284-dee74127cb87}" tripRequest
join "dvtable_city_observers" observers
    on observers."CityID" = tripRequest."City"
where tripRequest."InstanceID" = ANY(val_cardids);
```

Видим, что таблица `observers` соединяется с таблицей `tripRequest` по `"CityID"`. 
Это значит, что функция возвращает всех сотрудников, которые являются наблюдателями
для города, указанного в поле City для данной карточки.
Следовательно, если таблица observers отсортирована по `"CityID"`,
то СУБД может не сканировать всю таблицу observers, а найти первую строку,
содержащую тот же `"CityID"`, что и в поле "Город" карточки,
после чего возвращать значения атрибута `"EmployeeID"` из каждой строки до тех пор,
пока не встретит строку, содержащую другое значение `"CityID"`.

## Проблема
Таблица observers имеет первичный ключ `("EmployeeID", "CityID")`,
т.е. её строки сортируются в первую очередь по EmployeeID, а затем по `"CityID"`, что неоптимально по вышеизложенным причинам.

## Возможные решения
### Изменить первичный ключ с ("EmployeeID", "CityID") на ("CityID", "EmployeeID")
Плюсы:
- Сортировка строк производится в первую очередь по `"CityID"`, что позволяет быстрее фильтровать эту таблицу по `"CityID"` и соединять её c tripRequest

Минусы:
- Фильтрация по `"EmployeeID"` станет медленне (сейчас нам это не важно; если станет важно, можно будет добавить индекс)
- При изменении первичного ключа нужно вручную пересоздавать внешние ключи (в нашем случае это не проблема, т.к. другие таблицы не ссылаются на эту таблицу)

### Добавить индекс по CityID
Плюсы:
- Практически тот же прирост производительности, что при изменении первичного ключа,
но без возможных проблем с "ломанием" чего-то, что опирается на первичный ключ

Минусы:
- Накладные расходы, связанные с добавлением индекса: память на диске, замедление операций записи (insert, update, delete)

## Выводы
Меняем первичный ключ, потому что:
- не придется создавать новый индекс и нести соответствующие накладные расходы
- нет необходимости пересоздавать внешние ключи, так как на нашу таблицу другие таблицы не ссылаются
- это не прод и у нас есть бэкап, поэтому сломать базу данных и на время сделать таблицу недоступной не страшно. В проде безопаснее добавить индекс.

Код для изменения ПК:
```sql
ALTER TABLE "dvtable_city_observers"
DROP CONSTRAINT dvtable_city_observers_pkey;

ALTER TABLE "dvtable_city_observers"
ADD CONSTRAINT dvtable_city_observers_pkey
PRIMARY KEY ("CityID", "EmployeeID");
```
